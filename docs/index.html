<!-- References and Sources Listed at Document End: Denoted by [n]-->

<!-- Run Instructions:
    1) In command prompt either: 
    Python 3: python -m http.server 8000
    Python 2: python -m SimpleHTTPServer 8000
    2) In browser: http://localhost:8000/
    3) Navigate to location of index.html
    4) Ctrl-Shift-R is handy for reloading cached CSS
-->

<!-- Limitations:
    1) Only tested in Chrome
-->

<!DOCTYPE html>
<html lang="en">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Google wants a description because this is their tool.">

    <head>
        <title>CougarScope: Predictive Insights for Conservation and Coexistence</title>
        
        <!-- D3 JS Library -->
        <script type="text/javascript" src="d3.min.js"></script>
        <script type="text/javascript" src="plot.min.js"></script>
        <script type="text/javascript" src="topojson.v2.min.js"></script>

        <!-- CSS -->    
        <link rel="stylesheet" type="text/css" href="styles.css">
    </head>

    <body>
        <!-- HTML Elements -->
        <div id="navbar" class="initial-nav">
            <div class="wrapper-div">
                <a href="#" class="active">Home</a>
            </div>
        </div>
        <div id="navbar-spacing" class="container"></div>

        <div class="wrapper-div">
            <h1 class="title-text">CougarScope: Predictive Insights for Conservation and Coexistence</h1>

            <p class="body-text">
                Interactions between cougars, humans, and other animals present challenges in regions with high cougar activity. In the proposed study, data from the Washington Department of Fish and Wildlife (WDFW) and a novel cougar activity dataset will be used to investigate how clustering algorithms can be used to uncover patterns in cougar behavior and whether classifiers can predict high-impact cougar events. This project aims to enhance existing knowledge of cougar aggression behavior with the possibility of offering new insights, ultimately leading to improved public safety and wildlife conservation efforts.
            </p>

            <p class="body-text indent">
                The first dataset utilized in this research is the publically available Washington Department of Fish and Wildlife (WDFW) dataset. This dataset contains reports of cougar safety confrontations. Only reports that included confirmed sightings of cougars were included in this study. Additionally, extensive data cleaning was done due to inconsistent labeling and missing data. <b>Figure 1</b> below gives a basic summary of the locations of the reports from 2016 to 2025.
            </p> 

            <div id="county-tooltip"></div>
            <div id="state-choropleth" class="container"></div>
            <div id="choropleth-legend" class="legend container"></div>

            <p class="body-text figure-caption">
                Figure 1: The map above illustrates the count of confirmed cougar safety confrontations reported to the WDFW from 2016 to 2025, with darker colors indicating more reports.
            </p>

            <p class="body-text">
                In <b>Figure 1</b>, Stevens, Spokane, and Chelan county stand out as having the highest number of cougar safety confrontation reports. However, it is important to note that factors such as county population, topography, and land cover can affect these values. 
            </p>

            <p class="body-text indent">
                In addition to the cleaned WDFW dataset, a second dataset was collected using private Facebook posts of trail cameras in Washington State. Unlike the safety confrontation reports of the first dataset, this dataset is largely made up of cougar trail camera sightings, providing a different perspective of overall cougar movements.
                <b>Figure 2</b> below shows a map of the most popular GMUs for 2024 based on a sample, while <b>Figure 3</b> provides a visualization of cougar Facebook post dates based on an incomplete sample of the second cougar activity dataset.
            </p>

            <div id="gmu-tooltip"></div>
            <div id="gmu-choropleth" class="container"></div>
            <div id="gmu-choropleth-legend" class="legend container"></div>

            <p class="body-text figure-caption">
                Figure 2: The map above shows the number of cougar sightings reported to a private Facebook group during a time period in 2024. Black missing sections on the map represent national parks and indian reservations where GMUs do not exist.
            </p>

            <div id="necklace-tooltip"></div>
            <div id="cluster-viz" class="container"></div>

            <p class="body-text figure-caption">
                Figure 3: The plot above displays cougar sightings over time, separated by Game Management Unit (GMU). The size of each circle represents the number of cougars sighted on that date in that GMU.
            </p>

            <p class="body-text">
                Using both of the datasets described above, cougar activity and aggression data will be clustered to reveal patterns in cougar behavior. Additionally, earlier activity and other contextual features will be used in machine learning classifiers to predict future cougar activities.
            </p>

            <footer>
                <p class="footer">Â© 2025 Kailey Quesada. All research and content reserved.</p>
            </footer>

        </div>

        <!-- D3 and Vanilla JS -->
        <script>

            // Colors
            black = "000000"
            white = "#FFFFFF"
            light_green = "#97CCBB"
            dark_green = "#01402A"
            washington_yellow = "#FFD520"
            dark_washington_yellow = "#E6C200"
            washington_green = "#008457"
            choropleth_background_color = black

            // Dynamic SVG Function - Resize D3 Elements on Screen Resize
            function computeWidthHeight() {
                var container = document.getElementById("state-choropleth")
                var containerWidth = container.clientWidth
                var calculatedHeight = containerWidth / 1.5 // Width of Img Divided by Height of Img
                return {containerWidth, calculatedHeight}
            }

            function computeWidthHeightGMUChor() {
                var container = document.getElementById("gmu-choropleth")
                var containerWidth = container.clientWidth
                var calculatedHeight = containerWidth / 1.5 // Width of Img Divided by Height of Img
                return {containerWidth, calculatedHeight}
            }

            //var valueByIdGMU = d3.map() 

            ////  Promises  //////////////////////////////////////////////////////////////////
            Promise.all([
                d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-10m.json"),
                d3.json("Game_Management_Units_(Polygons)_2025.geojson"),
                d3.csv("2024_cougar_activity_data_sample_gmu_counts.csv", d => ({
                    GMU_Num: +d.GMU_Num.trim(),
                    value: +d.value.trim()
                })),
                d3.csv("wdfw_2016_to_2025_county_counts.csv"),
                d3.csv("2024_cougar_activity_data_sample_combined.csv")
            ]).then(function([us, gmu, gmu_counts, csv, csv2]) {
                // Save Values for Page Updates
                usData = us
                gmuData = gmu
                gmuCountData = gmu_counts
                csvData = csv
                csvData2 = csv2
                ready([usData, gmuData, gmuCountData, csvData, csvData2])
            })

            ////  Ready  //////////////////////////////////////////////////////////////////
            function ready([us, gmuData, gmuCountData, data, clusterdata]) {

                ////  State Choropleth  //////////////////////////////////////////////////////////////////

                // Create SVG for Choropleth
                var {containerWidth, calculatedHeight} = computeWidthHeight()
                var statechorsvg = d3.select("#state-choropleth")
                    .append("svg")
                    .attr("viewBox", [0, 0, containerWidth, calculatedHeight])
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .style("width", "100%")
                    .style("height", calculatedHeight + "px")
                    .style("background-color", choropleth_background_color)
                
                // This is the Washington State FIPS Code
                const stateId = "53"

                // This is the Mapping Stuff
                const counties = topojson.feature(us, us.objects.counties).features
                    .filter(d => d.id.startsWith(stateId))

                const state = topojson.feature(us, us.objects.states).features
                    .find(d => d.id === stateId)

                const projection = d3.geoMercator()
                    .fitSize([containerWidth, calculatedHeight], state)

                const path = d3.geoPath(projection)

                // This is Where we Define Colors for Counties
                const maxValue = d3.max(data, d => +d.value)
                const valueById = new Map(data.map(d => [d.fips, +d.value]))
                const color = d3.scaleSequential()
                    .domain([0, maxValue])
                    .interpolator(d3.interpolateRgb(light_green, dark_green))

                // This is Where we Draw the Lines
                statechorsvg.selectAll("path")
                    .data(counties)
                    .join("path")
                    .attr("d", path)
                    .attr("fill", d => {
                        const v = valueById.get(d.id)
                        return v == null ? white : color(v)
                    })
                    .attr("stroke", "black")
                    .attr("stroke-width", 0.25)
                    .attr("class", "county")
                    .on("mousemove", function(event, d) { // Show Value on Mouse Hover
                        const v = valueById.get(d.id)
                        const countyName = countyByFIPS.get(d.id)
                        d3.select("#county-tooltip")
                          .style("display", "block")
                          .style("left", (event.pageX + 10) + "px")
                          .style("top", (event.pageY - 10) + "px")
                          .html(`<strong>${countyName}</strong><br>${v == null ? "N/A" : v}`) // Represents Number of Reports, Not Number of Cougars Seen (Dataset 1 Limitation)
                    })
                    .on("mouseleave", function() { // Remove Value on Mouse Leave
                        d3.select("#county-tooltip").style("display", "none")
                    })
                    .on("click", function(event, d) { // Show Value On Click
                        const v = valueById.get(d.id)
                        const countyName = countyByFIPS.get(d.id)
                        d3.select("#county-tooltip")
                          .style("display", "block")
                          .style("left", (event.pageX + 10) + "px")
                          .style("top", (event.pageY - 10) + "px")
                          .html(`<strong>${countyName}</strong><br>${v == null ? "N/A" : v}`)
                    })

                // This is Where we Write the County Names
                const countyByFIPS = new Map(data.map(d => [d.fips, d.county]))
                statechorsvg.selectAll("text")
                    .data(counties)
                    .join("text")
                    .attr("x", d => path.centroid(d)[0])
                    .attr("y", d => path.centroid(d)[1])
                    .text(d => {
                        const fips = d.id
                        return countyByFIPS.get(fips)
                    })
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "central")
                    .attr("font-size", "clamp(6px, 0.8vw, 13px)") // For vw, use ((max px - min px) / ref width) * 100, where ref width is the screen size of the max px value. 
                    .attr("font-family", "sans-serif")
                    .attr("font-weight", "bold")
                    .attr("letter-spacing", 0.3)
                    .attr("fill", washington_yellow)
                    
                    // Choropleth Gradient Legend
                    d3.select("#choropleth-legend").selectAll("*").remove()
                    const legendWidth = 200
                    const legendHeight = 20 // Height of the bar alone.
                    const legendSvg = d3.select("#choropleth-legend")
                        .append("svg")
                        .attr("width", legendWidth)
                        .attr("height", 40) // Height of svg should be higher for number labels.

                    const defs = legendSvg.append("defs") // Gradient Itself
                    const gradient = defs.append("linearGradient")
                        .attr("id", "legend-gradient")

                    gradient.selectAll("stop")
                        .data(d3.range(0, 1.01, 0.01))
                        .enter().append("stop")
                        .attr("offset", d => `${d * 100}%`)
                        .attr("stop-color", d => color(d * maxValue))

                    legendSvg.append("rect") // Gradient Bar
                        .attr("x", 0)
                        .attr("y", 10)
                        .attr("width", legendWidth)
                        .attr("height", legendHeight)
                        .style("fill", "url(#legend-gradient)")

                    legendSvg.append("text") // Min Value Number Label
                        .attr("x", 0)
                        .attr("y", 35)
                        .attr("text-anchor", "start")
                        .attr("font-size", "12px")
                        .attr("fill", "#fff")
                        .text("0")

                    legendSvg.append("text") // Max Value Number Label
                        .attr("x", legendWidth)
                        .attr("y", 35)
                        .attr("text-anchor", "end")
                        .attr("font-size", "12px")
                        .attr("fill", "#fff")
                        .text(maxValue)

                
                //// GMU Choropleth  //////////////////////////////////////////////////////////////////

                // Create SVG for Choropleth
                var {containerWidth, calculatedHeight} = computeWidthHeightGMUChor()
                var statechorsvg2 = d3.select("#gmu-choropleth")
                    .append("svg")
                    .attr("viewBox", [0, 0, containerWidth, calculatedHeight])
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .style("width", "100%")
                    .style("height", calculatedHeight + "px")
                    .style("background-color", choropleth_background_color)

                // This is the Mapping Projection Stuff
                const gmuPolygons = gmuData.features // This is the GeoJSON Data from WDFW
                let projectionGMU = d3.geoIdentity() // Lots of Issues, Have to Use GeoIdentity
                    .reflectY(true)
                    .fitSize([containerWidth * 1.428, calculatedHeight], gmuData) // Scaling Fix Part II: By Trial and Error
                let pathGMU = d3.geoPath().projection(projectionGMU)
                const maxValueGMU = d3.max(gmuCountData, d => +d.value)
                const valueByIdGMU = new Map(gmuCountData.map(d => [d.GMU_Num, d.value]))
                
                // Define Color Scale
                const colorGMU = d3.scaleSequential()
                    .domain([0, maxValueGMU])
                    .interpolator(d3.interpolateRgb(light_green, dark_green))

                // This is Where we Draw the Lines
                statechorsvg2.selectAll("path")
                    .data(gmuPolygons)
                    .join("path")
                    .attr("d", pathGMU)
                    .attr("fill", d => {
                        const key = +d.properties.GMU_Num
                        const v = valueByIdGMU.get(key)
                        return v == 0 ? white : colorGMU(v)
                    })
                    .attr("stroke", "black")
                    .attr("stroke-width", 0.25)
                    .attr("class", "gmu")
                    .style("transform", 'scaleX(0.7)') // Scaling Fix Part I: https://stackoverflow.com/questions/66924720/resize-projection-in-d3js-in-only-one-axis-with-a-geojson-map
                    .on("mousemove", function(event, d) { // Show Value on Mouse Hover
                        const key = +d.properties.GMU_Num
                        const v = valueByIdGMU.get(key)
                        const gmuName = key
                        d3.select("#gmu-tooltip")
                          .style("display", "block")
                          .style("left", (event.pageX + 10) + "px")
                          .style("top", (event.pageY - 10) + "px")
                          .html(`<strong>GMU ${gmuName}</strong><br>${v == null ? "N/A" : v}`)
                    })
                    .on("mouseleave", function() { // Remove Value on Mouse Leave
                        d3.select("#gmu-tooltip").style("display", "none")
                    })
                    .on("click", function(event, d) { // Show Value On Click
                        const key = +d.properties.GMU_Num
                        const v = valueByIdGMU.get(key)
                        const gmuName = key
                        d3.select("#gmu-tooltip")
                          .style("display", "block")
                          .style("left", (event.pageX + 10) + "px")
                          .style("top", (event.pageY - 10) + "px")
                          .html(`<strong>GMU ${gmuName}</strong><br>${v == null ? "N/A" : v}`)
                    })

                // This is Where we Write the GMU Names
                // statechorsvg2.selectAll("text")
                //     .data(gmuPolygons)
                //     .join("text")
                //     .attr("x", d => pathGMU.centroid(d)[0] * 0.7) // Scaling Fix Part III: Match ScaleX Value
                //     .attr("y", d => pathGMU.centroid(d)[1])
                //     .text(d => {
                //         return d.properties.GMU_Num // We can also use the name as well.
                //     })
                //     .attr("text-anchor", "middle")
                //     .attr("alignment-baseline", "middle")
                //     .attr("font-size", "clamp(3px, 0.6vw, 10px)") // For vw, use ((max px - min px) / ref width) * 100, where ref width is the screen size of the max px value. 
                //     .attr("font-family", "sans-serif")
                //     .attr("font-weight", "bold")
                //     .attr("letter-spacing", 0.3)
                //     .attr("fill", d => {
                //         const key = +d.properties.GMU_Num
                //         const v = valueByIdGMU.get(key)
                //         return v == 0 ? dark_green : white
                //     })

                // Choropleth Gradient Legend
                d3.select("#gmu-choropleth-legend").selectAll("*").remove()
                const gmuLegendSvg = d3.select("#gmu-choropleth-legend")
                    .append("svg")
                    .attr("width", legendWidth)
                    .attr("height", 40) // Height of svg should be higher for number labels.

                const gmuDefs = gmuLegendSvg.append("defs") // Gradient Itself
                const gmuGradient = gmuDefs.append("linearGradient")
                    .attr("id", "gmu-legend-gradient")
                
                gmuGradient.selectAll("stop")
                    .data(d3.range(0, 1.01, 0.01))
                    .enter().append("stop")
                    .attr("offset", d => `${d * 100}%`)
                    .attr("stop-color", d => colorGMU(d * maxValueGMU))

                gmuLegendSvg.append("rect") // Gradient Bar
                    .attr("x", 0)
                    .attr("y", 10)
                    .attr("width", legendWidth)
                    .attr("height", legendHeight)
                    .style("fill", "url(#gmu-legend-gradient)")

                gmuLegendSvg.append("text") // Min Value Number Label
                    .attr("x", 0)
                    .attr("y", 35)
                    .attr("text-anchor", "start")
                    .attr("font-size", "12px")
                    .attr("fill", "#fff")
                    .text("0")

                gmuLegendSvg.append("text") // Max Value Number Label
                    .attr("x", legendWidth)
                    .attr("y", 35)
                    .attr("text-anchor", "end")
                    .attr("font-size", "12px")
                    .attr("fill", "#fff")
                    .text(maxValueGMU)
                
                
                ////  Clustering Visualization  //////////////////////////////////////////////////////////////////

                // Define Dynamic Variables for Different Render Sizes
                calculatedHeight = window.innerWidth < 900 ? (containerWidth * 2) : (containerWidth * 1) // Unlike the map, the height can be whatever we want for this element.
                let dynamicCircleSizeFactor = window.innerWidth < 600 ? (0.5) : (1)
                let dynamicPadding = window.innerWidth < 900 ? (50) : (70)
                let xaxistextpadding = window.innerWidth < 900 ? (calculatedHeight - dynamicPadding + 30) : (calculatedHeight - dynamicPadding + 45)

                // Create SVG for Clustering Viz
                var clustersvg = d3.select("#cluster-viz")
                    .append("svg")
                    .attr("viewBox", [0, 20, containerWidth, calculatedHeight])
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .style("width", "100%")
                    .style("height", calculatedHeight + "px")

                    // Grab Data
                    clusterdata.forEach(d => {
                        d.dateObj = new Date(d.date)
                        d.gmu = +String(d.gmu).split('/')[0]
                        d.numcougars = +d.numcougars
                    })

                    // Sort GMUs
                    const gmus = [...new Set(clusterdata.map(d => d.gmu))].sort((a, b) => a - b)

                    // X Scale for Date Values (Only Defines Mappings, Doesn't Draw Anything Yet)
                    const x = d3.scaleTime()
                        .domain(d3.extent(clusterdata, d => d.dateObj))
                        .range([dynamicPadding, containerWidth - dynamicPadding])

                    // Y Scale for Categorical GMU Values (Only Defines Mappings, Doesn't Draw Anything Yet)
                    const y = d3.scalePoint()
                        .domain(gmus)
                        .range([calculatedHeight - dynamicPadding, dynamicPadding])
                        .padding(0.5)

                    // Scale for Circle Radius (Only Defines Mappings, Doesn't Draw Anything Yet)
                    const r = d3.scaleSqrt()
                        .domain(d3.extent(clusterdata, d => d.numcougars))
                        .range([4, 10])

                    // Print Axes Baseline, Tickmarks, and Labels
                    clustersvg.append("g")
                        .attr("transform", `translate(0,${calculatedHeight-dynamicPadding})`)
                        .attr("class", "axis-values")
                        .call(d3.axisBottom(x))
                    clustersvg.append("g")
                        .attr("transform", `translate(${dynamicPadding},0)`)
                        .attr("class", "axis-values")
                        .call(d3.axisLeft(y))

                    // Print Circles
                    clustersvg.selectAll("circle")
                        .data(clusterdata)
                        .enter()
                        .append("circle")
                        .attr("cx", d => x(d.dateObj))
                        .attr("cy", d => y(d.gmu))
                        .attr("r", d => (r(d.numcougars) * dynamicCircleSizeFactor))
                        .attr("fill", "rgb(146, 199, 182)")
                        .attr("stroke", dark_green)
                        .attr("stroke-width", 2)
                        .attr("class", "circle")
                        .on("mousemove", function(event, d) { // Show Value on Mouse Hover
                            d3.select("#necklace-tooltip")
                                .style("display", "block")
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px")
                                .html(d ? `<strong>Num Cougars: ${d.numcougars}</strong><br>${d.date}<br>GMU ${d.gmu}` : "N/A")
                        })
                        .on("mouseleave", function() { // Remove Value on Mouse Leave
                            d3.select("#necklace-tooltip").style("display", "none")
                        })
                        .on("click", function(event, d) { // Show Value On Click
                            d3.select("#necklace-tooltip")
                                .style("display", "block")
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px")
                                .html(d ? `<strong>Num Cougars: ${d.numcougars}</strong><br>${d.date}<br>GMU ${d.gmu}` : "N/A")
                        })

                        // Print Horizontal Lines and Labels for Each GMU
                        clustersvg.selectAll(".gmu-line")
                            .data(gmus)
                            .enter()
                            .append("line")
                            .attr("class", "gmu-line")
                            .attr("x1", dynamicPadding)
                            .attr("x2", containerWidth - dynamicPadding)
                            .attr("y1", d => y(d))
                            .attr("y2", d => y(d))
                            .attr("stroke", (d, i) => i % 2 === 0 ? "gray" : "white") // Alternating stroke colors.
                            .attr("stroke-dasharray", "1,3")

                        // Count Number of Cougars in Each GMU using Accumulator Object
                        const gmuCounts = clusterdata.reduce((acc, d) => {
                            acc[d.gmu] = (acc[d.gmu] || 0) + d.numcougars
                            return acc
                        }, {})

                        // Print GMU Count Values
                        clustersvg.selectAll(".gmu-label")
                            .data(gmus)
                            .enter()
                            .append("text")
                            .attr("class", "gmu-label")
                            .attr("x", containerWidth - 50)
                            .attr("y", d => y(d) - 0)
                            .attr("fill", "white")
                            .attr("class", "axis-values")
                            .text(d => `${gmuCounts[d]}`)

                        // Print X Axis Label
                        clustersvg.append("text")
                            .attr("x", containerWidth / 2) 
                            .attr("y", xaxistextpadding)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .attr("class", "axis-label")
                            .text("Date Reported in 2024")

                        // Print Y Axis Label
                        clustersvg.append("text")
                            .attr("x", -calculatedHeight / 2)
                            .attr("y", 15) // Offset from left edge.
                            .attr("transform", "rotate(-90)")
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .attr("class", "axis-label")
                            .text("Game Management Unit (GMU)")

                        // Print GMU Count Label
                        clustersvg.append("text")
                            .attr("x", -calculatedHeight / 2)
                            .attr("y", containerWidth - 20) // Offset.
                            .attr("transform", "rotate(-90)")
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .attr("class", "axis-label")
                            .text("GMU Count")
            }

            ////  Navbar Scroll Function  //////////////////////////////////////////////////////////////////
            window.onscroll = function() {
                var navbar = document.getElementById('navbar')
                if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    navbar.classList.add('sticky')
                } else {
                    navbar.classList.remove('sticky')
                }
            }

            ////  Screen Resize Adjustment  //////////////////////////////////////////////////////////////////
            function resizeSVG() {

                // Clear D3 Containers for New D3 Elements
                var container = document.getElementById("state-choropleth");
                container.innerHTML = "";
                var container = document.getElementById("gmu-choropleth");
                container.innerHTML = "";
                var container = document.getElementById("cluster-viz");
                container.innerHTML = "";

                // Re-Generate
                ready([usData, gmuData, gmuCountData, csvData, csvData2])
            }

            window.addEventListener("resize", resizeSVG)

        </script>
    </body>

</html>